#!/usr/bin/python

import pyfits
import numpy as np

from pylab import *
from astLib import astPlots
from astLib import astWCS


#
# TODO:
#    - add a makeCube() function, with logEnergy as the 3rd dimension
#



def makeImage(centerRADec,geom=(300,300), FOV=(1.0,1.0), projection="CAR",
              output=None):
    """
    Generate a blank FITS image. Returns a HDU with the given geometry
    (so far in RA/Dec only). 

    Arguments:
    - `centerRADec`: (lambda,beta) center of image
    - `geom`: (N,M) size in pixels of the image
    - `FOV_deg`: (dx,dy) size of FOV in degrees
    - `output`: output filename, or None for no output
    """
  
    centerRADec=array(centerRADec)
    geom = array(geom)
    FOV = array(FOV)
    delta = FOV/geom
    
    hdu = pyfits.NP_pyfits.PrimaryHDU()
    hdu.data = zeros( geom )
    
    hdu.update_header()

    # Set up a cartesian projection that is basically flat at the
    # camera pointing position (so little distortion). This projection
    # isn't so good if you want to stitch together maps to make a
    # scan, but it minimizes distortion in the field of view, and
    # makes things like the acceptance and ring maps circular. Note
    # that RA/Dec lines will not be parallel in this projection in
    # general.

    hdu.header.add_comment("Generated by makefits.py")
    hdu.header.update( "CTYPE1", "RA---"+projection )
    hdu.header.update( "CTYPE2", "DEC--"+projection )
    hdu.header.update( "RADESYS", "fk5" )
    hdu.header.update( "EQUINOX", 2000 )
    
    hdu.header.update( "CRVAL1", centerRADec[0] )
    hdu.header.update( "CRVAL2", centerRADec[1] )
    hdu.header.update( "CRPIX1", geom[0]/2 )
    hdu.header.update( "CRPIX2", geom[1]/2 )

    hdu.header.update( "CDELT1", delta[0] )
    hdu.header.update( "CDELT2", delta[1] )
    
    hdu.header.update( "BSCALE", 1.0 )
    hdu.header.update( "BZERO", 0.0 )

    # NOTE: the following could be used for a projection with pixels
    # square in RA/Dec (as in the HESS software), but generally that's
    # not what we want since at high declination, it gives distorted
    # images (and the acceptance will be an oval). However, since the
    # tools take into account the projection correctly, it should
    # still work

    #    hdu.header.update( "CRVAL1", 0.0 )
    #    hdu.header.update( "CRVAL2", 0.0 )
    #    hdu.header.update( "LONPOLE", 0.0 )
    #    hdu.header.update( "CRPIX1", (geom[0]+1)/2 - centerRADec[0]/delta[0] )
    #    hdu.header.update( "CRPIX2", (geom[1]+1)/2 - centerRADec[1]/delta[1] )

    if output:
        pyfits.writeto(output, header=hdu.header, data=hdu.data )
        
    return hdu

def makeCountMap(hdu, ra,dec, output=None, verbose=False):
    """
    Arguments:
    - `hdu`: hdu containing data array and header with proper WCS info 
    - `ra`: array of RA coordinates
    - `dec`: array of Dec coordinates

    todo: add events coordsystem as an input (defaults to RA/Dec)
    """

    wcs = astWCS.WCS( hdu.header, mode='pyfits' )
    coords = array(wcs.wcs2pix( ra,dec ))

    bins = array(hdu.data.shape)
    pixsize = array( (wcs.getXPixelSizeDeg(),wcs.getYPixelSizeDeg()))
    
    
    imrange = zip( (0,0), bins) # TODO: probably need some half bins
                                                # here to make it
                                                # right?  check
                                                # histogram2d code
    if verbose:
        print "range: ",imrange
    
    
    H, xedges, yedges = histogram2d( coords[:,0],coords[:,1],
                                     bins=bins, range=imrange )
    
    if verbose:
        print "   H: ", H.shape
        print "data: ", hdu.data.shape
        
    if output:
        print "Writing count map:",output
        pyfits.writeto(output, header=hdu.header, data=H, clobber=True )

    return H

def copyheaders(ihdr,ohdr):
    """
    copies useful info form eventlist to image header

    Arguments:
    - `ihdu`: input header
    - `ohdu`: output header
    """
    
    keys = [ "RUN_ID", "DATE_OBS", "TIME_OBS",
             "DATE_END", "TIME_END", "TSTART", "TSTOP",
             "MJDREFI","MJDREFF", "TIMEUNIT", "TIMESYS", "TIMEREF",
             "TASSIGN", "TELAPSE", "ONTIME", "LIVETIME", "DEADC",
             "OBJECT", "RA_OBJ", "DEC_OBJ", "RA_PNT", "DEC_PNT",
             "ALT_PNT", "AZ_PNT", "RADESYS", "OBS_MODE", "TELLIST"]
             
    for key in keys:
        try:
            ohdr.update( key, ihdr[key] )
        except KeyError:
            pass


if __name__ == "__main__":

    from optparse import OptionParser

    center=[83.633333,22.014444]
    geom = [200,200]
    FOV= [5.0,5.0]

    parser = OptionParser()
    parser.add_option( "-f","--fov", dest="fov", help="field of view",
                       metavar="X,Y")
    parser.add_option( "-g","--geom", dest="geom", help="image geometry",
                       metavar="NX,NY")
    parser.add_option( "-c","--center", dest="center", help="image center degrees",
                       metavar="RA,Dec")

    parser.add_option( "-d","--display", action="store_true",
                       dest="display", help="show the image")

    parser.add_option( "-o","--output", dest="output", help="output filename")
    parser.add_option( "-p","--projection", dest="proj", help="projection",
                       default="CAR")
    parser.add_option( "-v","--verbose", dest="verbose", help="more output")
    parser.set_usage("makefits.py [options] eventsfile.fits")



    (options, args) = parser.parse_args()

    if (options.fov):
        FOV = array(options.fov.split(",")).astype(float)

    if (options.geom):
        geom = array(options.geom.split(",")).astype(float)

    if (options.center):
        center = array(options.center.split(",")).astype(float)

    if len(sys.argv)>1:
        inputfile = args.pop()
    else:
        print "Please specify at least an input file. See --help";
        sys.exit(1)

    if options.verbose:
        print "CENTER:",center
        print "  GEOM:",geom
        print "   FOV:",FOV

    # generate blank output image:
    hdu = makeImage( centerRADec=center, geom=geom, FOV=FOV,projection=options.proj)
    wcs = astWCS.WCS( hdu.header, mode='pyfits' )

    # get events
    ff=pyfits.open(inputfile)
    events = ff['EVENTS']
    ra = events.data.field("RA").astype(float)
    dec = events.data.field("DEC").astype(float)
    ehdr = events.header

    # update header with event information:
    copyheaders( ehdr, hdu.header )

    # make count map:

    newdata = makeCountMap( hdu, ra,dec, output=options.output,
                            verbose=options.verbose)



    #display it
    if options.display:
        img = astPlots.ImagePlot( newdata, wcs, 
                                  cutLevels=["relative", 99.5], 
                                  colorMapName="jet"   )
        img.draw()
        show()


